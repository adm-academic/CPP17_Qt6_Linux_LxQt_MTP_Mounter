# CPP17_Qt6_Linux_LxQt_MTP_Mounter
Программа для авто-монтирования устройств MTP (таких как смартфоны) для ОС Linux и DE LxQt. Написана на диалекте C++17 в программе QtCreator 16, GCC 15, Qt 6.9.1 в дистрибутиве Fedora Linux 42. Для работы требует наличие консольных программ bash,mountpoint,file,ls,fusermount, jmtpfs.


Этот вариант программы концептуально завершён и в целом завершён тоже. Бузесловно, есть недоработки и баги, но в целом программа работает так, как и задумывалась.

Когда я придумывал эту программу, я её видел именно как значёк в трее, который меняется в зависимости от подключенности смартфона. Сразу не предусматривалась работа нескольких смарфонов на одном компьютере. Сразу я хотел использовать шаблон "Машина Состояний". После того, как я описал первый класс машины состояний, я понял что делать хочу в блокирующем стиле, не используя асинхронных возможностей Qt. Ну и сразу стало понятно, что тогда машину состояний нужно выпосить в отдельный поток, что я собственоо и сделал. Так как взаимодействие отдельного потока и GUI Qt у меня простое, то получилось даже избежать использования мьютексов, обошёлся простыми сигналами-слотами, которые уже поддерживают многопоточность. 

Юзерам которые захотят упрекнуть меня в том, что я не взял встроенный в Qt "State Machine Framework", а нагородил свой огород с потоками и самодельной машиной состояний - я отвечу : 
Этот подход я сделал просто с заделом на переход на другой фреймворк, не Qt. Я давно хочу попрограммировать немного на FLTK или WxWidgets. И такая программа хорошо подходит на роль хэллоуворлда под эти библиотеки. Было-бы интересно реализовать её с новыми расширениями C++  в области многопоточности. Да и в целом, по поводу "асинхронного программирования". В русскогоязычном секторе интернета очень много постов по поводу ненужной Delphi и "формошлёпства". Программисты на таких технологиях называются некомпетентными. И в дополнение, в масштабах операционных систем. Если поставить любой современный дистрибутив Linux, при его загрузке отчётливо виден запуск ОЧЕНЬ большого количества системных сервисов. Также и Windows, сейчас она запускает сервисов намного больше чем в нулевых годах. Почему-же так? Неужели нельзя было се эти сервисы объеденить в один, более толстый, написанный на технологии асинхронного программирования? Думаю что ответ очевиден, программистам ОС было удобнее написать несколько сервисов, который распараллеливаются методом вытесняющей многозадачности самой ОС.

И ещё один момент, при реализации шаблона "State Machine" я не стал делать красивую "систему переходов" а всю логику оформил внутри метдов `loop` в виде обычных многоуровневых "ифов". Почему так? Потому что ещё в прошлом веке многоуровневые "ифы" и циклы были самой лучшей технологией под названием "структурное программирование". Самые лучшие учёные-информатики планеты продвигали именно структурное программирование как самый передовой вариант программирования. Молодые программисты нередко игнорируют "развеситые алгоритмы" и "портянки", ругаются на "длинные методы". Но это дело чисто личного отношения. Если идти путём "маленьких методов" и "красивых объектных конструкций" то можно легко прийти к большому и сложному коду, который будет непонятен с первого подхода. Лично я сторонник более простой объектной конструкции, которая достигается написание длинных и сложных методов ( в просторечии - портянок ). Это дело чистого вкуса. Повторюсь что "развесистый код" и "портянки" (пожалуйста извините меня за просторечия ) когда-то тоже были новейшей технологией разработки ПО, с качествами, доказанными умнейшими учёными планеты. 


Так что ещё раз отмечу, применённые мною в программе "блокирующий код", "потоки" и "развесистая логика из ифов" имеют своё право на жизнь. Тем более это язык C++, а не Delphi, где конечно это было-бы совсем неподходящим и неаккуратным.

